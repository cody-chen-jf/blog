{"id":"fill-jd-slider-captcha-by-puppeteer","title":"使用 Puppeteer 自动输入京东滑动验证码","date":"2018-11-05T09:39:33.386Z","tags":["Puppeteer","NodeJs"],"index":false,"draft":false,"html":"<!-- 「」 -->\n<p>京东网页端登录有时候需要输入滑动验证码，就像这样：</p>\n<p><img src=\"https://user-images.githubusercontent.com/5960988/48596434-ff732280-e993-11e8-94db-2f82be82a1ab.png\" alt=\"jd-verify\"></p>\n<p>在做自动签到脚本的时候遇到这个很不舒服，如果不处理的话就只能每次弹出浏览器手动登录，因此稍微研究了下。下面是一个非常简单，但成功率很高（达到80%）的自动识别并输入方案，使用 puppeteer 实现。</p>\n<p><strong>总体思路：通过图像特征识别出滑块缺口的位置，然后通过模拟用户点击将滑块拖动到该处。</strong></p>\n<!-- more -->\n<p>首先，我们能够看到这个滑块缺口是一个黑色半透明的遮罩区域，通过代码分析并不能得到它的具体色值。因此只能自行比对尝试。通过肉眼测试与对比，可以得到这个遮罩的色值大约为 <code>rgba(0,0,0,0.65)</code></p>\n<p><img src=\"https://user-images.githubusercontent.com/5960988/48612937-52b19900-e9c5-11e8-97c4-eab52883c540.png\" alt=\"img\"></p>\n<p>得到这个色值的目的是：通过判断相邻像素点 a, b 的色值之差，来决定像素点 b 的色值是否是像素点 a 的色值加上遮罩之后的结果，以此来推断遮罩所在的位置。</p>\n<p>下面介绍两个函数：</p>\n<ul>\n<li><code>combineRgba</code> rgba 色值相加，返回相加结果</li>\n<li><code>tolerance</code> rgba 色值比对，通过传入一个「容忍值」，返回颜色是否相似</li>\n</ul>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">/**\n * combine rgba colors [r, g, b, a]\n * @param rgba1 底色\n * @param rgba2 遮罩色\n * @returns {number[]}\n */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">combineRgba</span> (<span class=\"hljs-params\">rgba1: <span class=\"hljs-built_in\">number</span>[], rgba2: <span class=\"hljs-built_in\">number</span>[]</span>): <span class=\"hljs-title\">number</span>[] </span>{\n  <span class=\"hljs-keyword\">const</span> [r1, g1, b1, a1] = rgba1\n  <span class=\"hljs-keyword\">const</span> [r2, g2, b2, a2] = rgba2\n  <span class=\"hljs-keyword\">const</span> a = a1 + a2 - a1 * a2\n  <span class=\"hljs-keyword\">const</span> r = (r1 * a1 + r2 * a2 - r1 * a1 * a2) / a\n  <span class=\"hljs-keyword\">const</span> g = (g1 * a1 + g2 * a2 - g1 * a1 * a2) / a\n  <span class=\"hljs-keyword\">const</span> b = (b1 * a1 + b2 * a2 - b1 * a1 * a2) / a\n  <span class=\"hljs-keyword\">return</span> [r, g, b, a]\n}\n\n<span class=\"hljs-comment\">/**\n * 判断两个颜色是否相似\n * @param rgba1\n * @param rgba2\n * @param t\n * @returns {boolean}\n */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">tolerance</span> (<span class=\"hljs-params\">rgba1: <span class=\"hljs-built_in\">number</span>[], rgba2: <span class=\"hljs-built_in\">number</span>[], t: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">boolean</span> </span>{\n  <span class=\"hljs-keyword\">const</span> [r1, g1, b1] = rgba1\n  <span class=\"hljs-keyword\">const</span> [r2, g2, b2] = rgba2\n  <span class=\"hljs-keyword\">return</span> (\n    r1 &gt; r2 - t &amp;&amp; r1 &lt; r2 + t\n    &amp;&amp; g1 &gt; g2 - t &amp;&amp; g1 &lt; g2 + t\n    &amp;&amp; b1 &gt; b2 - t &amp;&amp; b1 &lt; b2 + t\n  )\n}\n</code></pre>\n<p>接下来就可以写出距离算法了，通过传入包含缺口的验证码图片的 base64 编码，以及图片的实际宽度，返回缺口位置 x 值。具体思路是：通过自左而右，自上而下的逐列像素分析，找出第一个跟上个像素的色值与遮罩色值相加后的结果相似的像素点，就认为是遮罩的 x 位置。</p>\n<p><img src=\"https://user-images.githubusercontent.com/5960988/48612892-33b30700-e9c5-11e8-94d7-a6cc6ec30c87.png\" alt=\"img\"></p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getVerifyPosition</span> (<span class=\"hljs-params\">base64: <span class=\"hljs-built_in\">string</span>, actualWidth: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">Promise</span>&lt;<span class=\"hljs-title\">number</span>&gt; </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> canvas = createCanvas(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-number\">1000</span>)\n    <span class=\"hljs-keyword\">const</span> ctx = canvas.getContext(<span class=\"hljs-string\">'2d'</span>)\n    <span class=\"hljs-keyword\">const</span> img = <span class=\"hljs-keyword\">new</span> Image()\n    img.onload = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> width: <span class=\"hljs-built_in\">number</span> = img.naturalWidth\n      <span class=\"hljs-keyword\">const</span> height: <span class=\"hljs-built_in\">number</span> = img.naturalHeight\n      ctx.drawImage(img, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>)\n      <span class=\"hljs-keyword\">const</span> maskRgba: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.65</span>]\n      <span class=\"hljs-keyword\">const</span> t: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">// 色差容忍值</span>\n      <span class=\"hljs-keyword\">let</span> prevPixelRgba = <span class=\"hljs-literal\">null</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">0</span>; x &lt; width; x++) {\n        <span class=\"hljs-comment\">// 重新开始一列，清除上个像素的色值</span>\n        prevPixelRgba = <span class=\"hljs-literal\">null</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-number\">0</span>; y &lt; height; y++) {\n          <span class=\"hljs-keyword\">const</span> rgba = ctx.getImageData(x, y, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>).data\n          <span class=\"hljs-keyword\">if</span> (prevPixelRgba) {\n            <span class=\"hljs-comment\">// 所有原图中的 alpha 通道值都是1</span>\n            prevPixelRgba[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">const</span> maskedPrevPixel = combineRgba(prevPixelRgba, maskRgba)\n            <span class=\"hljs-comment\">// 只要找到了一个色值匹配的像素点则直接返回，因为是自上而下，自左往右的查找，第一个像素点已经满足\"最近\"的条件</span>\n            <span class=\"hljs-keyword\">if</span> (tolerance(maskedPrevPixel, rgba, t)) {\n              resolve(x * actualWidth / width)\n              <span class=\"hljs-keyword\">return</span>\n            }\n          } <span class=\"hljs-keyword\">else</span> {\n            prevPixelRgba = rgba\n          }\n        }\n      }\n      <span class=\"hljs-comment\">// 没有找到任何符合条件的像素点</span>\n      resolve(<span class=\"hljs-number\">0</span>)\n    }\n    img.onerror = reject\n    img.src = base64\n  })\n}\n</code></pre>\n<p>得到 x 位置后，就可以使用 puppeteer 操纵滑块来实现验证了：</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// 验证码图片（带缺口）</span>\n<span class=\"hljs-keyword\">const</span> img = <span class=\"hljs-keyword\">await</span> page.$(<span class=\"hljs-string\">'.JDJRV-bigimg &gt; img'</span>)\n<span class=\"hljs-comment\">// 获取缺口左x坐标</span>\n<span class=\"hljs-keyword\">const</span> distance: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-keyword\">await</span> getVerifyPosition(\n  <span class=\"hljs-keyword\">await</span> page.evaluate(<span class=\"hljs-function\"><span class=\"hljs-params\">element</span> =&gt;</span> element.getAttribute(<span class=\"hljs-string\">'src'</span>), img),\n  <span class=\"hljs-keyword\">await</span> page.evaluate(<span class=\"hljs-function\"><span class=\"hljs-params\">element</span> =&gt;</span> <span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-built_in\">window</span>.getComputedStyle(element).width), img)\n)\n<span class=\"hljs-comment\">// 滑块</span>\n<span class=\"hljs-keyword\">const</span> dragBtn = <span class=\"hljs-keyword\">await</span> page.$(<span class=\"hljs-string\">'.JDJRV-slide-btn'</span>)\n<span class=\"hljs-keyword\">const</span> dragBtnPosition = <span class=\"hljs-keyword\">await</span> page.evaluate(<span class=\"hljs-function\"><span class=\"hljs-params\">element</span> =&gt;</span> {\n<span class=\"hljs-comment\">// 此处有 bug，无法直接返回 getBoundingClientRect()</span>\n  <span class=\"hljs-keyword\">const</span> {x, y, width, height} = element.getBoundingClientRect()\n  <span class=\"hljs-keyword\">return</span> {x, y, width, height}\n}, dragBtn)\n<span class=\"hljs-comment\">// 按下位置设置在滑块中心</span>\n<span class=\"hljs-keyword\">const</span> x: <span class=\"hljs-built_in\">number</span> = dragBtnPosition.x + dragBtnPosition.width / <span class=\"hljs-number\">2</span>\n<span class=\"hljs-keyword\">const</span> y: <span class=\"hljs-built_in\">number</span> = dragBtnPosition.y + dragBtnPosition.height / <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-keyword\">if</span> (distance &gt; <span class=\"hljs-number\">10</span>) {\n  <span class=\"hljs-comment\">// 如果距离够长，则将距离设置为二段（模拟人工操作）</span>\n  <span class=\"hljs-keyword\">const</span> distance1: <span class=\"hljs-built_in\">number</span> = distance - <span class=\"hljs-number\">10</span>\n  <span class=\"hljs-keyword\">const</span> distance2: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">10</span>\n  <span class=\"hljs-keyword\">await</span> page.mouse.move(x, y)\n  <span class=\"hljs-keyword\">await</span> page.mouse.down()\n  <span class=\"hljs-comment\">// 第一次滑动</span>\n  <span class=\"hljs-keyword\">await</span> page.mouse.move(x + distance1, y, {steps: <span class=\"hljs-number\">30</span>})\n  <span class=\"hljs-keyword\">await</span> page.waitFor(<span class=\"hljs-number\">500</span>)\n  <span class=\"hljs-comment\">// 第二次滑动</span>\n  <span class=\"hljs-keyword\">await</span> page.mouse.move(x + distance1 + distance2, y, {steps: <span class=\"hljs-number\">20</span>})\n  <span class=\"hljs-keyword\">await</span> page.waitFor(<span class=\"hljs-number\">500</span>)\n  <span class=\"hljs-keyword\">await</span> page.mouse.up()\n} <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-comment\">// 否则直接滑到相应位置</span>\n  <span class=\"hljs-keyword\">await</span> page.mouse.move(x, y)\n  <span class=\"hljs-keyword\">await</span> page.mouse.down()\n  <span class=\"hljs-keyword\">await</span> page.mouse.move(x + distance, y, {steps: <span class=\"hljs-number\">30</span>})\n  <span class=\"hljs-keyword\">await</span> page.mouse.up()\n}\n<span class=\"hljs-comment\">// 等待验证结果</span>\n<span class=\"hljs-keyword\">await</span> page.waitFor(<span class=\"hljs-number\">3000</span>)\n</code></pre>\n<p><img src=\"https://user-images.githubusercontent.com/5960988/48613026-91dfea00-e9c5-11e8-988b-42d823a3699a.png\" alt=\"img\"></p>\n<p>大概就这样。</p>\n"}